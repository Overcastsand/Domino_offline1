<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Domino Offline Detector — Live + Solver</title>
<style>
  :root{--accent:#0b84ff;--muted:#6b7280}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:14px;color:#111}
  h1{font-size:18px;margin:0 0 8px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button,input,select{font-size:14px;padding:8px;border-radius:10px;border:1px solid #ddd}
  .panel{border:1px dashed #ddd;border-radius:12px;padding:10px;margin-top:10px}
  .muted{color:var(--muted)}
  #video,#canvas,#outCanvas,#chainCanvas{width:100%;max-width:100%;border-radius:12px;border:1px solid #eee;background:#fff}
  .mode{display:inline-flex;align-items:center;gap:6px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  .badge{background:#eef;border-radius:999px;padding:2px 8px;font-size:12px}
  .ok{color:#0a7d1e}.err{color:#b91c1c}
  .ctrls{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
  .ctrls label{display:flex;flex-direction:column;font-size:12px;color:#333}
  .ctrls input[type="range"]{width:100%}
</style>
</head>
<body>
<h1>Domino Offline Detector</h1>
<div class="row">
  <label class="mode">Mode:
    <select id="modeSel">
      <option value="simple">Simple</option>
      <option value="full" selected>Full (Live Camera)</option>
    </select>
  </label>
  <span id="cvStatus" class="badge">OpenCV: loading…</span>
</div>

<!-- TUNING -->
<div class="panel">
  <h3 style="margin:0 0 6px">Detection Tuning</h3>
  <div class="ctrls">
    <label>Canny Low <span><input id="cannyLow" type="range" min="10" max="200" value="60"><span id="cannyLowV" class="muted">60</span></span></label>
    <label>Canny High <span><input id="cannyHigh" type="range" min="40" max="300" value="150"><span id="cannyHighV" class="muted">150</span></span></label>
    <label>Min Pip % (of half) <span><input id="pipMin" type="range" min="1" max="20" value="2"><span id="pipMinV" class="muted">2%</span></span></label>
    <label>Max Pip % (of half) <span><input id="pipMax" type="range" min="5" max="60" value="20"><span id="pipMaxV" class="muted">20%</span></span></label>
    <label>Realtime FPS (every ms) <span><input id="rtMs" type="range" min="200" max="1200" value="500"><span id="rtMsV" class="muted">500 ms</span></span></label>
    <div class="row"><button id="applyBtn">Apply</button><span class="muted">Changes affect next detect</span></div>
  </div>
</div>

<!-- SIMPLE MODE -->
<div id="simpleBox" class="panel" style="display:none">
  <div class="grid">
    <input id="fileInput" type="file" accept="image/*">
    <div class="row">
      <button id="detectSimpleBtn">Detect Dominos</button>
      <button id="clearSimpleBtn">Clear</button>
      <button id="annotateSimpleBtn">Annotate Order</button>
    </div>
    <canvas id="outCanvas" width="1280" height="720"></canvas>
    <div class="row">
      <label>Starting double:
        <select id="startSimple"></select>
      </label>
      <button id="solveSimpleBtn">Solve Longest Train</button>
    </div>
    <div><b>Detected:</b> <span id="listSimple" class="muted">–</span></div>
    <div><b>Solution:</b> <span id="solSimple" class="muted">–</span></div>
  </div>
</div>

<!-- FULL (LIVE CAMERA) MODE -->
<div id="fullBox" class="panel">
  <div class="grid">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas" width="1280" height="720" style="display:block"></canvas>
    <div class="row">
      <button id="startCamBtn">Start Camera</button>
      <button id="stopCamBtn">Stop Camera</button>
      <button id="snapBtn">Capture Frame</button>
      <button id="detectLiveBtn">Detect (Snapshot)</button>
      <label class="mode">Realtime:
        <select id="rtSel">
          <option value="off">Off</option>
          <option value="on" selected>On</option>
        </select>
      </label>
      <button id="saveImgBtn">Save Annotated</button>
      <button id="annotateFullBtn">Annotate Order</button>
    </div>
    <div class="row">
      <label>Starting double:
        <select id="startFull"></select>
      </label>
      <button id="solveFullBtn">Solve Longest Train</button>
    </div>
    <div><b>Detected:</b> <span id="listFull" class="muted">–</span></div>
    <div><b>Solution:</b> <span id="solFull" class="muted">–</span></div>
    <div id="log" class="muted">Ready.</div>
  </div>
</div>

<!-- CHAIN STRIP with REALISTIC DOMINOS -->
<div class="panel">
  <h3 style="margin:0 0 6px">Visual Chain</h3>
  <canvas id="chainCanvas" width="1400" height="240"></canvas>
</div>

<script src="opencv.js"></script>
<script>
/* UI refs */
const modeSel = document.getElementById('modeSel');
const simpleBox = document.getElementById('simpleBox');
const fullBox = document.getElementById('fullBox');
const cvStatus = document.getElementById('cvStatus');
const listSimple = document.getElementById('listSimple');
const listFull = document.getElementById('listFull');
const solSimple = document.getElementById('solSimple');
const solFull = document.getElementById('solFull');
const logEl = document.getElementById('log');

const cannyLow = document.getElementById('cannyLow');
const cannyHigh = document.getElementById('cannyHigh');
const pipMin = document.getElementById('pipMin');
const pipMax = document.getElementById('pipMax');
const rtMs = document.getElementById('rtMs');
const cannyLowV = document.getElementById('cannyLowV');
const cannyHighV = document.getElementById('cannyHighV');
const pipMinV = document.getElementById('pipMinV');
const pipMaxV = document.getElementById('pipMaxV');
const rtMsV = document.getElementById('rtMsV');
const applyBtn = document.getElementById('applyBtn');

[cannyLow,cannyHigh,pipMin,pipMax,rtMs].forEach(inp=>{
  inp.addEventListener('input', ()=>{
    cannyLowV.textContent = cannyLow.value;
    cannyHighV.textContent = cannyHigh.value;
    pipMinV.textContent = pipMin.value+'%';
    pipMaxV.textContent = pipMax.value+'%';
    rtMsV.textContent = rtMs.value+' ms';
  });
});

let P={ cannyLow:60, cannyHigh:150, pipMinPct:2, pipMaxPct:20, rtInterval:500 };
applyBtn.addEventListener('click', ()=>{
  P={ cannyLow:+cannyLow.value, cannyHigh:+cannyHigh.value, pipMinPct:+pipMin.value, pipMaxPct:+pipMax.value, rtInterval:+rtMs.value };
  if (rtTimer){ clearInterval(rtTimer); rtTimer=setInterval(rtTick, P.rtInterval); }
  setLog('Applied tuning.');
});

for (let i=12;i>=0;i--){
  const o1=document.createElement('option'); o1.value=i;o1.textContent=i; startSimple.appendChild(o1);
  const o2=document.createElement('option'); o2.value=i;o2.textContent=i; startFull.appendChild(o2);
}
startSimple.value = 12; startFull.value = 12;

modeSel.addEventListener('change', ()=>{
  const full = modeSel.value==='full';
  fullBox.style.display = full ? '' : 'none';
  simpleBox.style.display = full ? 'none' : '';
});

function setStatus(ok,msg){ cvStatus.textContent='OpenCV: '+msg; cvStatus.className='badge '+(ok?'ok':'err'); }
function setLog(msg){ logEl.textContent = msg; }

/* OpenCV ready */
let cvReady=false;
cv['onRuntimeInitialized']=function(){ cvReady=true; setStatus(true,'ready'); };

/* ---------- Core CV ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function findTiles(src){
  const gray=new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  const blur=new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);
  const edges=new cv.Mat(); cv.Canny(blur, edges, P.cannyLow, P.cannyHigh);
  const kernel=cv.Mat.ones(3,3,cv.CV_8U);
  cv.dilate(edges, edges, kernel);

  const contours=new cv.MatVector(), hierarchy=new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const rects=[]; const W=src.cols, H=src.rows;
  for(let i=0;i<contours.size();i++){
    const cnt=contours.get(i);
    const r=cv.boundingRect(cnt);
    const area=r.width*r.height;
    if (area<800 || r.width>0.9*W || r.height>0.9*H){ cnt.delete(); continue; }
    const ar=r.width/r.height; if (ar<0.35 || ar>3.0){ cnt.delete(); continue; }
    const pad=Math.floor(0.06*Math.max(r.width,r.height));
    rects.push({x: clamp(r.x-pad,0,W), y: clamp(r.y-pad,0,H),
                w: clamp(r.width+2*pad,1,W-r.x), h: clamp(r.height+2*pad,1,H-r.y)});
    cnt.delete();
  }
  gray.delete(); blur.delete(); edges.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
  rects.sort((a,b)=> (b.w*b.h)-(a.w*a.h));
  const kept=[];
  rects.forEach(r=>{
    let keep=true;
    for(const k of kept){
      const x1=Math.max(r.x,k.x), y1=Math.max(r.y,k.y);
      const x2=Math.min(r.x+r.w, k.x+k.w), y2=Math.min(r.y+r.h, k.y+k.h);
      const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1);
      const a1=r.w*r.h, a2=k.w*k.h;
      if (inter/Math.min(a1,a2) > 0.6){ keep=false; break; }
    }
    if (keep) kept.push(r);
  });
  return kept;
}

function splitHalves(src, box){
  const roi=src.roi(new cv.Rect(box.x, box.y, box.w, box.h));
  const gh=new cv.Mat(); cv.cvtColor(roi, gh, cv.COLOR_RGBA2GRAY, 0);
  let halves=[];
  if (box.w >= box.h){
    const colMin = [];
    for(let x=0;x<gh.cols;x++){
      let m=255; for(let y=0;y<gh.rows;y++) m=Math.min(m, gh.ucharPtr(y,x)[0]);
      colMin.push(m);
    }
    let best=1e9, bestX=0, k=3;
    for(let x=0;x<colMin.length;x++){
      let s=0,c=0; for(let dx=-k;dx<=k;dx++){ const xx=Math.max(0,Math.min(colMin.length-1,x+dx)); s+=colMin[xx]; c++; }
      const avg=s/c; if (avg<best){ best=avg; bestX=x; }
    }
    halves=[{x:box.x,y:box.y,w:bestX,h:box.h},{x:box.x+bestX,y:box.y,w:box.w-bestX,h:box.h}];
  } else {
    const rowMin = [];
    for(let y=0;y<gh.rows;y++){
      let m=255; for(let x=0;x<gh.cols;x++) m=Math.min(m, gh.ucharPtr(y,x)[0]);
      rowMin.push(m);
    }
    let best=1e9, bestY=0, k=3;
    for(let y=0;y<rowMin.length;y++){
      let s=0,c=0; for(let dy=-k;dy<=k;dy++){ const yy=Math.max(0,Math.min(rowMin.length-1,y+dy)); s+=rowMin[yy]; c++; }
      const avg=s/c; if (avg<best){ best=avg; bestY=y; }
    }
    halves=[{x:box.x,y:box.y,w:box.w,h:bestY},{x:box.x,y:box.y+bestY,w:box.w,h:box.h-bestY}];
  }
  roi.delete(); gh.delete();
  return halves.map(h=>({x:h.x,y:h.y,w:Math.max(1,h.w),h:Math.max(1,h.h)}));
}

function drawBoxes(canvas, boxes, labels){
  const ctx=canvas.getContext('2d');
  ctx.strokeStyle='#00cc66'; ctx.lineWidth=2; ctx.font='16px system-ui';
  boxes.forEach((b,i)=>{
    ctx.strokeRect(b.x,b.y,b.w,b.h);
    if (labels && labels[i]){
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(b.x+4,b.y+4,46,20);
      ctx.fillStyle='#fff'; ctx.fillText(labels[i], b.x+8, b.y+20);
    }
  });
}

function countPips(src, half){
  const roi=src.roi(new cv.Rect(half.x, half.y, half.w, half.h));
  const g=new cv.Mat(); cv.cvtColor(roi,g,cv.COLOR_RGBA2GRAY,0);
  cv.equalizeHist(g,g);
  const bw=new cv.Mat();
  cv.adaptiveThreshold(g,bw,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY_INV,31,7);
  const kernel=cv.Mat.ones(3,3,cv.CV_8U);
  cv.morphologyEx(bw,bw,cv.MORPH_OPEN,kernel);
  const contours=new cv.MatVector(), hierarchy=new cv.Mat();
  cv.findContours(bw, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const area=half.w*half.h; let n=0;
  for(let i=0;i<contours.size();i++){
    const c=contours.get(i);
    const a=cv.contourArea(c);
    if (a < (P.pipMinPct/100)*area || a > (P.pipMaxPct/100)*area){ c.delete(); continue; }
    const r=cv.boundingRect(c);
    const ratio=Math.min(r.width,r.height)/Math.max(r.width,r.height);
    if (ratio<0.4){ c.delete(); continue; }
    n++; c.delete();
  }
  roi.delete(); g.delete(); bw.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
  return Math.max(0, Math.min(12, n));
}

function detectDominos(src, drawCanvas){
  const boxes = findTiles(src);
  const labels=[], pairs=[];
  for (const b of boxes){
    const halves = splitHalves(src,b);
    const a = countPips(src, halves[0]);
    const c = countPips(src, halves[1]);
    labels.push(`${a}-${c}`);
    pairs.push([a,c]);
  }
  if (drawCanvas){
    const ctx=drawCanvas.getContext('2d');
    ctx.drawImage(drawCanvas._img,0,0);
    drawBoxes(drawCanvas, boxes, labels);
    drawCanvas._boxes = boxes;
  }
  return {boxes, pairs, labels};
}

/* ---------- Solver + visuals ---------- */
function longestTrain(dominoes, start=null){
  const n=dominoes.length; let best={len:0, chain:[], idxs:[]};
  function dfs(open, used, chain, idxs){
    let moved=false;
    for(let i=0;i<n;i++){
      if(used & (1<<i)) continue;
      const [a,b]=dominoes[i];
      if(a===open){ moved=true; dfs(b, used|(1<<i), chain.concat([[a,b]]), idxs.concat([i])); }
      else if(b===open){ moved=true; dfs(a, used|(1<<i), chain.concat([[b,a]]), idxs.concat([i])); }
    }
    if(!moved && chain.length>best.len) best={len:chain.length, chain:chain.slice(), idxs:idxs.slice()};
  }
  if(start==null){
    for(let i=0;i<n;i++){ const [a,b]=dominoes[i]; dfs(b,1<<i,[[a,b]],[i]); if(a!==b) dfs(a,1<<i,[[b,a]],[i]); }
  } else {
    dfs(start,0,[],[]);
    for(let i=0;i<n;i++){ const [a,b]=dominoes[i]; if(a===start) dfs(b,1<<i,[[a,b]],[i]); if(b===start) dfs(a,1<<i,[[b,a]],[i]); }
  }
  return best;
}

const chainCanvas = document.getElementById('chainCanvas');
function drawChain(chain){
  const ctx=chainCanvas.getContext('2d');
  ctx.clearRect(0,0,chainCanvas.width,chainCanvas.height);
  const tileW=110, tileH=170, pad=12, startX=16, startY=30;
  let x=startX, y=startY;
  for (let i=0;i<chain.length;i++){
    const [a,b]=chain[i];
    drawRealDomino(ctx,x,y,tileW,tileH,a,b);
    // order bubble
    ctx.fillStyle='#0b84ff'; ctx.beginPath(); ctx.arc(x+18,y+18,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(String(i+1), x+18, y+18);
    x+=tileW+pad;
    if (x+tileW>chainCanvas.width){ x=startX; y+=tileH+pad; }
  }
}
function drawRealDomino(ctx,x,y,w,h,a,b){
  ctx.save();
  ctx.shadowColor='rgba(0,0,0,0.25)'; ctx.shadowBlur=12; ctx.shadowOffsetY=6;
  ctx.fillStyle='#fdfdfc'; roundRect(ctx,x,y,w,h,16,true,false);
  ctx.restore();
  ctx.strokeStyle='#222'; ctx.lineWidth=2; roundRect(ctx,x,y,w,h,16,false,true);
  const g=ctx.createLinearGradient(x,y,x,y+h); g.addColorStop(0,'#fff'); g.addColorStop(1,'#f1f1ef');
  ctx.fillStyle=g; roundRect(ctx,x+2,y+2,w-4,h-4,14,true,false);
  ctx.strokeStyle='#333'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x+w/2,y+8); ctx.lineTo(x+w/2,y+h-8); ctx.stroke();
  drawPips(ctx, x, y, w/2, h, a);
  drawPips(ctx, x+w/2, y, w/2, h, b);
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}
function drawPips(ctx, x,y,w,h,count){
  const pip=(px,py)=>{
    ctx.save();
    const rg=ctx.createRadialGradient(px-1,py-1,1, px,py,7);
    rg.addColorStop(0,'#222'); rg.addColorStop(1,'#000');
    ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=0.25; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(px-2,py-3,2.5,0,Math.PI*2); ctx.fill();
    ctx.restore();
  };
  const cx=x+w/2, cy=y+h/2, dx=w/4, dy=h/4;
  const P1=[[cx,cy]];
  const P2=[[cx-dx,cy-dy],[cx+dx,cy+dy]];
  const P3=[[cx-dx,cy-dy],[cx,cy],[cx+dx,cy+dy]];
  const P4=[[cx-dx,cy-dy],[cx+dx,cy-dy],[cx-dx,cy+dy],[cx+dx,cy+dy]];
  const P5=[[cx-dx,cy-dy],[cx+dx,cy-dy],[cx,cy],[cx-dx,cy+dy],[cx+dx,cy+dy]];
  const P6=[[cx-dx,cy-dy],[cx+dx,cy-dy],[cx-dx,cy],[cx+dx,cy],[cx-dx,cy+dy],[cx+dx,cy+dy]];
  const drawL=(arr)=>arr.forEach(p=>pip(p[0],p[1]));
  if(count===0) return;
  if(count===1) return drawL(P1);
  if(count===2) return drawL(P2);
  if(count===3) return drawL(P3);
  if(count===4) return drawL(P4);
  if(count===5) return drawL(P5);
  if(count===6) return drawL(P6);
  drawL(P6);
  const extras=[[x+w-14, y+14],[x+14, y+h-14],[x+14,y+14],[x+w-14,y+h-14],[cx, y+14],[cx, y+h-14]];
  for(let i=0;i<Math.min(count-6,extras.length);i++) pip(extras[i][0], extras[i][1]);
}

/* annotate order numbers on photo */
function annotateOrder(canvas, chainIdxs){
  if (!canvas._boxes || !canvas._boxes.length) return;
  const ctx=canvas.getContext('2d');
  ctx.drawImage(canvas._img,0,0);
  // redraw boxes for context
  drawBoxes(canvas, canvas._boxes, canvas._labels || null);
  chainIdxs.forEach((idx, order)=>{
    const b = canvas._boxes[idx];
    if (!b) return;
    const cx = b.x + b.w/2, cy = b.y + b.h/2;
    ctx.fillStyle='#0b84ff'; ctx.beginPath(); ctx.arc(cx, cy, 16, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='14px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(String(order+1), cx, cy);
  });
}

/* ---------- SIMPLE mode ---------- */
const fileInput = document.getElementById('fileInput');
const outCanvas = document.getElementById('outCanvas');
const detectSimpleBtn = document.getElementById('detectSimpleBtn');
const clearSimpleBtn = document.getElementById('clearSimpleBtn');
const annotateSimpleBtn = document.getElementById('annotateSimpleBtn');
const startSimple = document.getElementById('startSimple');
const solveSimpleBtn = document.getElementById('solveSimpleBtn');
let simpleImg=null;

fileInput.addEventListener('change',()=>{
  const f=fileInput.files?.[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const img=new Image(); img.onload=()=>{
    outCanvas.width=img.width; outCanvas.height=img.height;
    const ctx=outCanvas.getContext('2d'); ctx.drawImage(img,0,0);
    outCanvas._img=img; simpleImg=img; listSimple.textContent='–'; solSimple.textContent='–';
  }; img.src=url;
});

detectSimpleBtn.addEventListener('click', ()=>{
  if(!cvReady) return alert('OpenCV not ready');
  if(!simpleImg) return alert('Load an image first');
  const src=cv.imread(outCanvas);
  const res=detectDominos(src, outCanvas);
  src.delete();
  outCanvas._pairs=res.pairs; outCanvas._boxes=res.boxes; outCanvas._labels=res.labels;
  listSimple.textContent = res.pairs.map(p=>p.join('-')).join(', ') || '–';
});
solveSimpleBtn.addEventListener('click', ()=>{
  const pairs=outCanvas._pairs||[]; if(!pairs.length) return alert('No dominos detected');
  const start=+startSimple.value; const best=longestTrain(pairs,start);
  solSimple.textContent = best.chain.length? best.chain.map(p=>p.join('-')).join(' , ') : 'No chain';
  drawChain(best.chain);
  outCanvas._bestIdxs = best.idxs;
});
annotateSimpleBtn.addEventListener('click', ()=>{
  if (!outCanvas._bestIdxs) return alert('Solve first');
  annotateOrder(outCanvas, outCanvas._bestIdxs);
});
clearSimpleBtn.addEventListener('click', ()=>{
  const ctx=outCanvas.getContext('2d'); ctx.clearRect(0,0,outCanvas.width,outCanvas.height);
  listSimple.textContent='–'; solSimple.textContent='–'; outCanvas._pairs=[]; outCanvas._boxes=[]; outCanvas._labels=[]; outCanvas._bestIdxs=null;
});

/* ---------- FULL mode (live) ---------- */
const video=document.getElementById('video');
const canvas=document.getElementById('canvas');
const startCamBtn=document.getElementById('startCamBtn');
const stopCamBtn=document.getElementById('stopCamBtn');
const snapBtn=document.getElementById('snapBtn');
const detectLiveBtn=document.getElementById('detectLiveBtn');
const saveImgBtn=document.getElementById('saveImgBtn');
const annotateFullBtn=document.getElementById('annotateFullBtn');
const rtSel=document.getElementById('rtSel');
const startFull=document.getElementById('startFull');
const solveFullBtn=document.getElementById('solveFullBtn');
let stream=null, rtTimer=null;

async function startCam(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject=stream; setLog('Camera started.');
  }catch(e){ alert('Camera error: '+e); }
}
function stopCam(){ if(stream){stream.getTracks().forEach(t=>t.stop()); stream=null;} if(rtTimer){clearInterval(rtTimer); rtTimer=null;} setLog('Camera stopped.'); }
function drawFromVideo(){
  const vw=video.videoWidth, vh=video.videoHeight; if(!vw||!vh) return false;
  canvas.width=vw; canvas.height=vh;
  const ctx=canvas.getContext('2d'); ctx.drawImage(video,0,0,vw,vh);
  canvas._img=new Image(); canvas._img.src=canvas.toDataURL('image/png'); return true;
}
function detectOnCanvas(){
  if(!cvReady||!canvas._img) return;
  const src=cv.imread(canvas); const res=detectDominos(src, canvas); src.delete();
  listFull.textContent = res.pairs.map(p=>p.join('-')).join(', ') || '–';
  canvas._pairs=res.pairs; canvas._boxes=res.boxes; canvas._labels=res.labels;
}
function rtTick(){ if(drawFromVideo()) detectOnCanvas(); }

startCamBtn.addEventListener('click', async ()=>{
  await startCam();
  if (rtSel.value==='on'){ if(rtTimer) clearInterval(rtTimer); rtTimer=setInterval(rtTick, P.rtInterval); setLog('Realtime: ON'); }
  else setLog('Realtime: OFF (use Capture/Detect)');
});
stopCamBtn.addEventListener('click', stopCam);
snapBtn.addEventListener('click', ()=>{ if(drawFromVideo()){ const ctx=canvas.getContext('2d'); ctx.drawImage(canvas._img,0,0); setLog('Snapshot.'); } else setLog('Waiting for camera…'); });
detectLiveBtn.addEventListener('click', ()=>{ if(!drawFromVideo()) return setLog('No frame'); detectOnCanvas(); setLog('Detected.'); });
rtSel.addEventListener('change', ()=>{
  if(rtSel.value==='on'){ if(rtTimer) clearInterval(rtTimer); rtTimer=setInterval(rtTick, P.rtInterval); setLog('Realtime: ON'); }
  else { if(rtTimer) clearInterval(rtTimer); rtTimer=null; setLog('Realtime: OFF'); }
});
saveImgBtn.addEventListener('click', ()=>{ const a=document.createElement('a'); a.download='domino_annotated.png'; a.href=canvas.toDataURL('image/png'); a.click(); });
solveFullBtn.addEventListener('click', ()=>{
  const pairs=canvas._pairs||[]; if(!pairs.length) return alert('No dominos detected');
  const start=+startFull.value; const best=longestTrain(pairs,start);
  solFull.textContent = best.chain.length? best.chain.map(p=>p.join('-')).join(' , ') : 'No chain';
  drawChain(best.chain);
  canvas._bestIdxs = best.idxs;
});
annotateFullBtn.addEventListener('click', ()=>{
  if (!canvas._bestIdxs) return alert('Solve first');
  annotateOrder(canvas, canvas._bestIdxs);
});
</script>

<!--
==============================================
OFFLINE SETUP (one time)
==============================================
1) Download OpenCV.js and place it next to this HTML:
   https://docs.opencv.org/4.x/opencv.js
   Save as: opencv.js

2) Put in a folder on your phone:
   Domino_Offline/
     ├── domino_offline.html
     └── opencv.js

3) Open domino_offline.html in Safari. Allow camera when prompted.

Tips:
- Use the sliders if detection misses pips/tiles.
- After "Solve", see the chain in the bottom canvas (realistic dominos).
- "Annotate Order" draws numbered bubbles on the original photo.
-->
</body>
</html>
